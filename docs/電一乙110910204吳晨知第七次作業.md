# 程式設計
<h2>第十章</h2>  
<h3>電子工程系一年乙班</h3>  
<h5>110910204</h5>  
<h5>吳晨知</h5>  
<h5>教授：李金譚</h5>  

# 目錄

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->
<!-- code_chunk_output -->

- [程式設計](#程式設計)
- [目錄](#目錄)
- [筆記](#筆記)
  - [ISO C++ forbids converting a string constant to ‘char*’](#iso-c-forbids-converting-a-string-constant-to-char)
- [作業](#作業)
  - [9.4 a~i](#94-a~i)
  - [9.5 a~h](#95-a~h)
    - [Fix](#fix)
      - [b](#b)
      - [c](#c)
      - [d](#d)
      - [e](#e)
      - [h](#h)
  - [9.7 %d 和 %i 的差異](#97-d-和-i-的差異)
  - [9.10 溫度轉換](#910-溫度轉換)
- [參考資料](#參考資料)

<!-- /code_chunk_output -->

# 筆記
## ISO C++ forbids converting a string constant to ‘char*’
在設定變數時，如果使用C語言字型轉換，將會出現上述警告訊息，使用指定到反參考中，系統會自動進行型態定義，但使用參考的方式這部份並未強制定義，這時統會進行implicit conversion 操作，

這到底是怎麼一回事呢？事實上，我們在學習c或者c++的時候都知道，如果在賦值操作的時候，等號兩邊的變量類型不一樣，那麼編譯器會進行一種叫做implicit conversion的操作來使得變量可以被賦值。

在我們上面的表達式中就存在這樣的一個問題，等號右邊的`"abc"`是一個不變常量，在c++中叫做string literal，type是`const char *`，而p則是一個`char`指針。如果強行指定會發生什麼呢？沒錯，就是將右邊的常量強制類型轉換成一個指針，結果就是我們在修改一個const變數。編譯運行的結果會因編譯器和操作系統共同決定，有的編譯器會通過，有的會警告，就算過了也可能因為操作系統的敏感性而被殺掉。

像這種直接將string literal賦值給指針的操作被開發者們認為是deprecated，只不過由於以前很多代碼都有這種習慣，為了相容就保留下來了。

# 作業
# 參考資料
https://stackoverflow.com/questions/20944784/why-is-conversion-from-string-constant-to-char-valid-in-c-but-invalid-in-c/20944858
https://blog.csdn.net/whatday/article/details/106267398
